<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AssetTrackerRK: UbloxCommandBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AssetTrackerRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">UbloxCommandBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for reading or writing a u-blox command.  
 <a href="class_ublox_command_base.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_ublox_g_p_s_8h_source.html">UbloxGPS.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for UbloxCommandBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_ublox_command_base.png" usemap="#UbloxCommandBase_map" alt=""/>
  <map id="UbloxCommandBase_map" name="UbloxCommandBase_map">
<area href="class_ublox_command.html" title="Class to hold a command to send or a command to decode." alt="UbloxCommand&lt; PAYLOAD_SIZE &gt;" shape="rect" coords="0,56,218,80"/>
<area href="class_ublox_command.html" alt="UbloxCommand&lt; 100 &gt;" shape="rect" coords="228,56,446,80"/>
<area href="class_ublox.html" title="Class for implementing u-blox GPS support." alt="Ublox" shape="rect" coords="228,112,446,136"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9263f0d1a04cccb5cd18827f5d6bef36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a9263f0d1a04cccb5cd18827f5d6bef36">UbloxCommandBase</a> (uint8_t *<a class="el" href="class_ublox_command_base.html#ad8920498db562fd8a143df6eae566b8f">buffer</a>, size_t <a class="el" href="class_ublox_command_base.html#a84741dbce09fad55b4f19e8a4980015c">bufferSize</a>)</td></tr>
<tr class="memdesc:a9263f0d1a04cccb5cd18827f5d6bef36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="class_ublox_command_base.html" title="Class for reading or writing a u-blox command.">UbloxCommandBase</a> object. Normally you'd use <a class="el" href="class_ublox_command.html" title="Class to hold a command to send or a command to decode.">UbloxCommand</a> instead, which handles the buffer management for you.  <a href="class_ublox_command_base.html#a9263f0d1a04cccb5cd18827f5d6bef36">More...</a><br /></td></tr>
<tr class="separator:a9263f0d1a04cccb5cd18827f5d6bef36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5ab231f02e3836b8c9bbeab0ddeab7"><td class="memItemLeft" align="right" valign="top"><a id="a6a5ab231f02e3836b8c9bbeab0ddeab7"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a6a5ab231f02e3836b8c9bbeab0ddeab7">~UbloxCommandBase</a> ()</td></tr>
<tr class="memdesc:a6a5ab231f02e3836b8c9bbeab0ddeab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a6a5ab231f02e3836b8c9bbeab0ddeab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece0b19378edc0a6d4f91afab2e38aaa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aece0b19378edc0a6d4f91afab2e38aaa">decode</a> (char ch)</td></tr>
<tr class="memdesc:aece0b19378edc0a6d4f91afab2e38aaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a single character.  <a href="class_ublox_command_base.html#aece0b19378edc0a6d4f91afab2e38aaa">More...</a><br /></td></tr>
<tr class="separator:aece0b19378edc0a6d4f91afab2e38aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533b864304bf39e8252a9bed0cb9a04a"><td class="memItemLeft" align="right" valign="top"><a id="a533b864304bf39e8252a9bed0cb9a04a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a533b864304bf39e8252a9bed0cb9a04a">discardToNextSync1</a> ()</td></tr>
<tr class="memdesc:a533b864304bf39e8252a9bed0cb9a04a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to discard invalid data. You probably won't need to call this. <br /></td></tr>
<tr class="separator:a533b864304bf39e8252a9bed0cb9a04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d1e2235a35f385c4d52b28e2354357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#ae7d1e2235a35f385c4d52b28e2354357">updateChecksum</a> ()</td></tr>
<tr class="memdesc:ae7d1e2235a35f385c4d52b28e2354357"><td class="mdescLeft">&#160;</td><td class="mdescRight">When preparing a command to send, updates the checksum, sync, and length bytes.  <a href="class_ublox_command_base.html#ae7d1e2235a35f385c4d52b28e2354357">More...</a><br /></td></tr>
<tr class="separator:ae7d1e2235a35f385c4d52b28e2354357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4da9aa9fbba3ffc7d7484fbaf7ddd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aaf4da9aa9fbba3ffc7d7484fbaf7ddd6">calculateChecksum</a> (uint8_t &amp;ckA, uint8_t &amp;ckB) const</td></tr>
<tr class="memdesc:aaf4da9aa9fbba3ffc7d7484fbaf7ddd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the checksum based on the data in the buffer.  <a href="class_ublox_command_base.html#aaf4da9aa9fbba3ffc7d7484fbaf7ddd6">More...</a><br /></td></tr>
<tr class="separator:aaf4da9aa9fbba3ffc7d7484fbaf7ddd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae086799cdb19344e81cc4fbb1579c552"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#ae086799cdb19344e81cc4fbb1579c552">addHandler</a> (<a class="el" href="struct_ublox_message_handler.html">UbloxMessageHandler</a> *handler)</td></tr>
<tr class="memdesc:ae086799cdb19344e81cc4fbb1579c552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a message handler.  <a href="class_ublox_command_base.html#ae086799cdb19344e81cc4fbb1579c552">More...</a><br /></td></tr>
<tr class="separator:ae086799cdb19344e81cc4fbb1579c552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1f896b201c033d912a7702f504d47d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#acb1f896b201c033d912a7702f504d47d">removeHandler</a> (<a class="el" href="struct_ublox_message_handler.html">UbloxMessageHandler</a> *handler)</td></tr>
<tr class="memdesc:acb1f896b201c033d912a7702f504d47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a message handler.  <a href="class_ublox_command_base.html#acb1f896b201c033d912a7702f504d47d">More...</a><br /></td></tr>
<tr class="separator:acb1f896b201c033d912a7702f504d47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838d8182bd08740f0610ecf143422667"><td class="memItemLeft" align="right" valign="top"><a id="a838d8182bd08740f0610ecf143422667"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a838d8182bd08740f0610ecf143422667">callHandlers</a> ()</td></tr>
<tr class="memdesc:a838d8182bd08740f0610ecf143422667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally to call all of the message handlers that match this class and id. <br /></td></tr>
<tr class="separator:a838d8182bd08740f0610ecf143422667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4346dd7808f05bdf8acef3bed7305fbf"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a4346dd7808f05bdf8acef3bed7305fbf">getMsgClass</a> () const</td></tr>
<tr class="memdesc:a4346dd7808f05bdf8acef3bed7305fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the message class of the current command.  <a href="class_ublox_command_base.html#a4346dd7808f05bdf8acef3bed7305fbf">More...</a><br /></td></tr>
<tr class="separator:a4346dd7808f05bdf8acef3bed7305fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd331b5f31f22d5fc973f75ad944511"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a6bd331b5f31f22d5fc973f75ad944511">getMsgId</a> () const</td></tr>
<tr class="memdesc:a6bd331b5f31f22d5fc973f75ad944511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the message ID of the current command.  <a href="class_ublox_command_base.html#a6bd331b5f31f22d5fc973f75ad944511">More...</a><br /></td></tr>
<tr class="separator:a6bd331b5f31f22d5fc973f75ad944511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb64996e19ca00e8afaf11713e47e929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#abb64996e19ca00e8afaf11713e47e929">setClassId</a> (uint8_t msgClass, uint8_t msgId)</td></tr>
<tr class="memdesc:abb64996e19ca00e8afaf11713e47e929"><td class="mdescLeft">&#160;</td><td class="mdescRight">When sending a message, sets the message class and ID.  <a href="class_ublox_command_base.html#abb64996e19ca00e8afaf11713e47e929">More...</a><br /></td></tr>
<tr class="separator:abb64996e19ca00e8afaf11713e47e929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc5b067842891aead7618409f6bd12d"><td class="memItemLeft" align="right" valign="top"><a id="afbc5b067842891aead7618409f6bd12d"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#afbc5b067842891aead7618409f6bd12d">getPayloadLen</a> () const</td></tr>
<tr class="memdesc:afbc5b067842891aead7618409f6bd12d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the payload length, the number of bytes available from <a class="el" href="class_ublox_command_base.html#a77e19c1e96d033e46667e1d3840be609" title="Get a const pointer to the data payload.">getData()</a> <br /></td></tr>
<tr class="separator:afbc5b067842891aead7618409f6bd12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e19c1e96d033e46667e1d3840be609"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a77e19c1e96d033e46667e1d3840be609">getData</a> () const</td></tr>
<tr class="memdesc:a77e19c1e96d033e46667e1d3840be609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const pointer to the data payload.  <a href="class_ublox_command_base.html#a77e19c1e96d033e46667e1d3840be609">More...</a><br /></td></tr>
<tr class="separator:a77e19c1e96d033e46667e1d3840be609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb3dd16ba5a250aa8de3419a9db7819"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a8bb3dd16ba5a250aa8de3419a9db7819">getData</a> (size_t offset, void *data, size_t dataLen) const</td></tr>
<tr class="memdesc:a8bb3dd16ba5a250aa8de3419a9db7819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies data from the buffer.  <a href="class_ublox_command_base.html#a8bb3dd16ba5a250aa8de3419a9db7819">More...</a><br /></td></tr>
<tr class="separator:a8bb3dd16ba5a250aa8de3419a9db7819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7a95332632c5066d69ce61c583d14a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#acb7a95332632c5066d69ce61c583d14a">setData</a> (size_t offset, const void *data, size_t dataLen)</td></tr>
<tr class="memdesc:acb7a95332632c5066d69ce61c583d14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set data in the buffer.  <a href="class_ublox_command_base.html#acb7a95332632c5066d69ce61c583d14a">More...</a><br /></td></tr>
<tr class="separator:acb7a95332632c5066d69ce61c583d14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d3c7bf15161fe9d7ddfa228e5027bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a64d3c7bf15161fe9d7ddfa228e5027bc">appendData</a> (const void *data, size_t dataLen)</td></tr>
<tr class="memdesc:a64d3c7bf15161fe9d7ddfa228e5027bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends data into the buffer at the current payloadLen.  <a href="class_ublox_command_base.html#a64d3c7bf15161fe9d7ddfa228e5027bc">More...</a><br /></td></tr>
<tr class="separator:a64d3c7bf15161fe9d7ddfa228e5027bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d2adc2d96ff22c588fdacbc0ef0e0a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a2d2adc2d96ff22c588fdacbc0ef0e0a2">fillData</a> (uint8_t value, size_t dataLen)</td></tr>
<tr class="memdesc:a2d2adc2d96ff22c588fdacbc0ef0e0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Works like <a class="el" href="class_ublox_command_base.html#a64d3c7bf15161fe9d7ddfa228e5027bc" title="Appends data into the buffer at the current payloadLen.">appendData()</a>, but fill with a value instead.  <a href="class_ublox_command_base.html#a2d2adc2d96ff22c588fdacbc0ef0e0a2">More...</a><br /></td></tr>
<tr class="separator:a2d2adc2d96ff22c588fdacbc0ef0e0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a0c4b229a790013191f236f3b1d9d6"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a78a0c4b229a790013191f236f3b1d9d6">getU1</a> (size_t offset) const</td></tr>
<tr class="memdesc:a78a0c4b229a790013191f236f3b1d9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a uint8_t value at offset.  <a href="class_ublox_command_base.html#a78a0c4b229a790013191f236f3b1d9d6">More...</a><br /></td></tr>
<tr class="separator:a78a0c4b229a790013191f236f3b1d9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304c0f303a31f10fa11ce1b6ffea6772"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a304c0f303a31f10fa11ce1b6ffea6772">setU1</a> (size_t offset, uint8_t value)</td></tr>
<tr class="memdesc:a304c0f303a31f10fa11ce1b6ffea6772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a uint8_t value at offset in the payload.  <a href="class_ublox_command_base.html#a304c0f303a31f10fa11ce1b6ffea6772">More...</a><br /></td></tr>
<tr class="separator:a304c0f303a31f10fa11ce1b6ffea6772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d9d12a5f0c11844a939dba462a2781"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a06d9d12a5f0c11844a939dba462a2781">appendU1</a> (uint8_t value)</td></tr>
<tr class="memdesc:a06d9d12a5f0c11844a939dba462a2781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a uint8_t value to the current end of the payload.  <a href="class_ublox_command_base.html#a06d9d12a5f0c11844a939dba462a2781">More...</a><br /></td></tr>
<tr class="separator:a06d9d12a5f0c11844a939dba462a2781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada96285fe2158d42634140395fb53a3e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#ada96285fe2158d42634140395fb53a3e">getI1</a> (size_t offset) const</td></tr>
<tr class="memdesc:ada96285fe2158d42634140395fb53a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a int8_t value (signed) at offset.  <a href="class_ublox_command_base.html#ada96285fe2158d42634140395fb53a3e">More...</a><br /></td></tr>
<tr class="separator:ada96285fe2158d42634140395fb53a3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e3b8317e6f2cec6ad5de724d16b9629"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a7e3b8317e6f2cec6ad5de724d16b9629">setI1</a> (size_t offset, int8_t value)</td></tr>
<tr class="memdesc:a7e3b8317e6f2cec6ad5de724d16b9629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a int8_t value at offset in the payload.  <a href="class_ublox_command_base.html#a7e3b8317e6f2cec6ad5de724d16b9629">More...</a><br /></td></tr>
<tr class="separator:a7e3b8317e6f2cec6ad5de724d16b9629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae374f6e713344bbe13d186f7b143ead"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aae374f6e713344bbe13d186f7b143ead">appendI1</a> (int8_t value)</td></tr>
<tr class="memdesc:aae374f6e713344bbe13d186f7b143ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a int8_t value to the current end of the payload.  <a href="class_ublox_command_base.html#aae374f6e713344bbe13d186f7b143ead">More...</a><br /></td></tr>
<tr class="separator:aae374f6e713344bbe13d186f7b143ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29197d921458c875da464d368f23667"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#af29197d921458c875da464d368f23667">getU2</a> (size_t offset) const</td></tr>
<tr class="memdesc:af29197d921458c875da464d368f23667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a uint16_t value (little endian) at offset.  <a href="class_ublox_command_base.html#af29197d921458c875da464d368f23667">More...</a><br /></td></tr>
<tr class="separator:af29197d921458c875da464d368f23667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc951ba43cfb76a4bb04ab72ab22428"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a9fc951ba43cfb76a4bb04ab72ab22428">setU2</a> (size_t offset, uint16_t value)</td></tr>
<tr class="memdesc:a9fc951ba43cfb76a4bb04ab72ab22428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a uint16_t value at offset in the payload.  <a href="class_ublox_command_base.html#a9fc951ba43cfb76a4bb04ab72ab22428">More...</a><br /></td></tr>
<tr class="separator:a9fc951ba43cfb76a4bb04ab72ab22428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eea3ddda57d3d85983bb0338b56b9c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a0eea3ddda57d3d85983bb0338b56b9c3">appendU2</a> (uint16_t value)</td></tr>
<tr class="memdesc:a0eea3ddda57d3d85983bb0338b56b9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a uint16_t value to the current end of the payload.  <a href="class_ublox_command_base.html#a0eea3ddda57d3d85983bb0338b56b9c3">More...</a><br /></td></tr>
<tr class="separator:a0eea3ddda57d3d85983bb0338b56b9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad8f5d8d4b200f4f81f9f3ca09b0f2a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#abad8f5d8d4b200f4f81f9f3ca09b0f2a">getI2</a> (size_t offset) const</td></tr>
<tr class="memdesc:abad8f5d8d4b200f4f81f9f3ca09b0f2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a int16_t value (little endian, signed) at offset.  <a href="class_ublox_command_base.html#abad8f5d8d4b200f4f81f9f3ca09b0f2a">More...</a><br /></td></tr>
<tr class="separator:abad8f5d8d4b200f4f81f9f3ca09b0f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18b3a8bed75047390e85a1bf32c7452"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#ab18b3a8bed75047390e85a1bf32c7452">setI2</a> (size_t offset, int16_t value)</td></tr>
<tr class="memdesc:ab18b3a8bed75047390e85a1bf32c7452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an int16_t value at offset in the payload.  <a href="class_ublox_command_base.html#ab18b3a8bed75047390e85a1bf32c7452">More...</a><br /></td></tr>
<tr class="separator:ab18b3a8bed75047390e85a1bf32c7452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dadab2a36ba3cfc0c1517c52395ecd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a65dadab2a36ba3cfc0c1517c52395ecd">appendI2</a> (int16_t value)</td></tr>
<tr class="memdesc:a65dadab2a36ba3cfc0c1517c52395ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append an int16_t value to the current end of the payload.  <a href="class_ublox_command_base.html#a65dadab2a36ba3cfc0c1517c52395ecd">More...</a><br /></td></tr>
<tr class="separator:a65dadab2a36ba3cfc0c1517c52395ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b475884d9b26285d94c7e34153dd26"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a75b475884d9b26285d94c7e34153dd26">getU4</a> (size_t offset) const</td></tr>
<tr class="memdesc:a75b475884d9b26285d94c7e34153dd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a uint32_t value (little endian, 4 bytes) at offset.  <a href="class_ublox_command_base.html#a75b475884d9b26285d94c7e34153dd26">More...</a><br /></td></tr>
<tr class="separator:a75b475884d9b26285d94c7e34153dd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa857449f4958362f3bdd6694efe7e9d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aa857449f4958362f3bdd6694efe7e9d8">setU4</a> (size_t offset, uint32_t value)</td></tr>
<tr class="memdesc:aa857449f4958362f3bdd6694efe7e9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a uint32_t value at offset in the payload.  <a href="class_ublox_command_base.html#aa857449f4958362f3bdd6694efe7e9d8">More...</a><br /></td></tr>
<tr class="separator:aa857449f4958362f3bdd6694efe7e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa027e266c4b9ad381bfb572f81496d0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aa027e266c4b9ad381bfb572f81496d0d">appendU4</a> (uint32_t value)</td></tr>
<tr class="memdesc:aa027e266c4b9ad381bfb572f81496d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a uint32_t value to the current end of the payload.  <a href="class_ublox_command_base.html#aa027e266c4b9ad381bfb572f81496d0d">More...</a><br /></td></tr>
<tr class="separator:aa027e266c4b9ad381bfb572f81496d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168ded9ad47fa30ae603d686361c9394"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a168ded9ad47fa30ae603d686361c9394">getI4</a> (size_t offset) const</td></tr>
<tr class="memdesc:a168ded9ad47fa30ae603d686361c9394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a int32_t value (little endian, 4 bytes, signed) at offset.  <a href="class_ublox_command_base.html#a168ded9ad47fa30ae603d686361c9394">More...</a><br /></td></tr>
<tr class="separator:a168ded9ad47fa30ae603d686361c9394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad443d6a2899b9a8c15a6e13cdbc3260"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aad443d6a2899b9a8c15a6e13cdbc3260">setI4</a> (size_t offset, int32_t value)</td></tr>
<tr class="memdesc:aad443d6a2899b9a8c15a6e13cdbc3260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an int16_t value at offset in the payload.  <a href="class_ublox_command_base.html#aad443d6a2899b9a8c15a6e13cdbc3260">More...</a><br /></td></tr>
<tr class="separator:aad443d6a2899b9a8c15a6e13cdbc3260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87c0832061f228e8ec044fc4d0db027a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a87c0832061f228e8ec044fc4d0db027a">appendI4</a> (int32_t value)</td></tr>
<tr class="memdesc:a87c0832061f228e8ec044fc4d0db027a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a int32_t value to the current end of the payload.  <a href="class_ublox_command_base.html#a87c0832061f228e8ec044fc4d0db027a">More...</a><br /></td></tr>
<tr class="separator:a87c0832061f228e8ec044fc4d0db027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30dd417787f80a9575984da3d69d127"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aa30dd417787f80a9575984da3d69d127">getR4</a> (size_t offset) const</td></tr>
<tr class="memdesc:aa30dd417787f80a9575984da3d69d127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a float value (4 bytes) at offset.  <a href="class_ublox_command_base.html#aa30dd417787f80a9575984da3d69d127">More...</a><br /></td></tr>
<tr class="separator:aa30dd417787f80a9575984da3d69d127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a9d4e1f5f06cb347dadae334cf177e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a84a9d4e1f5f06cb347dadae334cf177e">setR4</a> (size_t offset, float value)</td></tr>
<tr class="memdesc:a84a9d4e1f5f06cb347dadae334cf177e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an float (4 byte floating point) value at offset in the payload.  <a href="class_ublox_command_base.html#a84a9d4e1f5f06cb347dadae334cf177e">More...</a><br /></td></tr>
<tr class="separator:a84a9d4e1f5f06cb347dadae334cf177e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f5f4889713ab6be8b0ec9bab182495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aa9f5f4889713ab6be8b0ec9bab182495">appendR4</a> (float value)</td></tr>
<tr class="memdesc:aa9f5f4889713ab6be8b0ec9bab182495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a float (4 byte floating point) value to the current end of the payload.  <a href="class_ublox_command_base.html#aa9f5f4889713ab6be8b0ec9bab182495">More...</a><br /></td></tr>
<tr class="separator:aa9f5f4889713ab6be8b0ec9bab182495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9bc6f1a01c10d7646abc18ea4a4b9d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a8f9bc6f1a01c10d7646abc18ea4a4b9d">getR8</a> (size_t offset) const</td></tr>
<tr class="memdesc:a8f9bc6f1a01c10d7646abc18ea4a4b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a double value (8 bytes) at offset.  <a href="class_ublox_command_base.html#a8f9bc6f1a01c10d7646abc18ea4a4b9d">More...</a><br /></td></tr>
<tr class="separator:a8f9bc6f1a01c10d7646abc18ea4a4b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe715ff5f6db189e933e2ec54385fd9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#abe715ff5f6db189e933e2ec54385fd9b">setR8</a> (size_t offset, double value)</td></tr>
<tr class="memdesc:abe715ff5f6db189e933e2ec54385fd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an double (8 byte floating point) value at offset in the payload.  <a href="class_ublox_command_base.html#abe715ff5f6db189e933e2ec54385fd9b">More...</a><br /></td></tr>
<tr class="separator:abe715ff5f6db189e933e2ec54385fd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca88125e18a5018d70cc594e4943824a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aca88125e18a5018d70cc594e4943824a">appendR8</a> (double value)</td></tr>
<tr class="memdesc:aca88125e18a5018d70cc594e4943824a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a double (8 byte floating point) value to the current end of the payload.  <a href="class_ublox_command_base.html#aca88125e18a5018d70cc594e4943824a">More...</a><br /></td></tr>
<tr class="separator:aca88125e18a5018d70cc594e4943824a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047170818080f4badf0620a1f459f7c0"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a047170818080f4badf0620a1f459f7c0">getBuffer</a> () const</td></tr>
<tr class="memdesc:a047170818080f4badf0620a1f459f7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the buffer, typically to send data.  <a href="class_ublox_command_base.html#a047170818080f4badf0620a1f459f7c0">More...</a><br /></td></tr>
<tr class="separator:a047170818080f4badf0620a1f459f7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07d0e1ef2a41d6b85ff9eed360a8d26"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#ab07d0e1ef2a41d6b85ff9eed360a8d26">getSendLength</a> () const</td></tr>
<tr class="memdesc:ab07d0e1ef2a41d6b85ff9eed360a8d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the data, typically to send it.  <a href="class_ublox_command_base.html#ab07d0e1ef2a41d6b85ff9eed360a8d26">More...</a><br /></td></tr>
<tr class="separator:ab07d0e1ef2a41d6b85ff9eed360a8d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:adfa70f366997c784b1d41aa8a4418d91"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#adfa70f366997c784b1d41aa8a4418d91">State</a> { <a class="el" href="class_ublox_command_base.html#adfa70f366997c784b1d41aa8a4418d91ab64d8c8054fdfc6dab8b856c7aa09858">State::LOOKING_FOR_START</a>, 
<a class="el" href="class_ublox_command_base.html#adfa70f366997c784b1d41aa8a4418d91a8f51100c7f9334d754f35a4291c892db">State::LOOKING_FOR_LENGTH</a>, 
<a class="el" href="class_ublox_command_base.html#adfa70f366997c784b1d41aa8a4418d91abfa1f0ec96ca1a5490b0c3a846d7479c">State::LOOKING_FOR_MESSAGE</a>
 }</td></tr>
<tr class="memdesc:adfa70f366997c784b1d41aa8a4418d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">u-blox parsing state constants  <a href="class_ublox_command_base.html#adfa70f366997c784b1d41aa8a4418d91">More...</a><br /></td></tr>
<tr class="separator:adfa70f366997c784b1d41aa8a4418d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad8920498db562fd8a143df6eae566b8f"><td class="memItemLeft" align="right" valign="top"><a id="ad8920498db562fd8a143df6eae566b8f"></a>
uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#ad8920498db562fd8a143df6eae566b8f">buffer</a></td></tr>
<tr class="memdesc:ad8920498db562fd8a143df6eae566b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer to hold data (received data or data for composing a packet to send) <br /></td></tr>
<tr class="separator:ad8920498db562fd8a143df6eae566b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84741dbce09fad55b4f19e8a4980015c"><td class="memItemLeft" align="right" valign="top"><a id="a84741dbce09fad55b4f19e8a4980015c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a84741dbce09fad55b4f19e8a4980015c">bufferSize</a></td></tr>
<tr class="memdesc:a84741dbce09fad55b4f19e8a4980015c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of the buffer. Maximum payload is bufferSize - HEADER_PLUS_CRC_LEN. <br /></td></tr>
<tr class="separator:a84741dbce09fad55b4f19e8a4980015c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996813aa7fe6906d73a2d110fc8d662c"><td class="memItemLeft" align="right" valign="top"><a id="a996813aa7fe6906d73a2d110fc8d662c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a996813aa7fe6906d73a2d110fc8d662c">bufferOffset</a> = 0</td></tr>
<tr class="memdesc:a996813aa7fe6906d73a2d110fc8d662c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current offset being written to in buffer when using encode() <br /></td></tr>
<tr class="separator:a996813aa7fe6906d73a2d110fc8d662c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2618bf58c8902e934b7637360377eb"><td class="memItemLeft" align="right" valign="top"><a id="a3d2618bf58c8902e934b7637360377eb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a3d2618bf58c8902e934b7637360377eb">payloadLen</a> = 0</td></tr>
<tr class="memdesc:a3d2618bf58c8902e934b7637360377eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of the data payload (0 = no data). This does not include the header or CRC. <br /></td></tr>
<tr class="separator:a3d2618bf58c8902e934b7637360377eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444d1c5768f2684ec118b15193bfa32d"><td class="memItemLeft" align="right" valign="top"><a id="a444d1c5768f2684ec118b15193bfa32d"></a>
<a class="el" href="class_ublox_command_base.html#adfa70f366997c784b1d41aa8a4418d91">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a444d1c5768f2684ec118b15193bfa32d">state</a> = <a class="el" href="class_ublox_command_base.html#adfa70f366997c784b1d41aa8a4418d91ab64d8c8054fdfc6dab8b856c7aa09858">State::LOOKING_FOR_START</a></td></tr>
<tr class="memdesc:a444d1c5768f2684ec118b15193bfa32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current parsing state. <br /></td></tr>
<tr class="separator:a444d1c5768f2684ec118b15193bfa32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e3d9b52bdfc2f7a4f5f130482d6aea"><td class="memItemLeft" align="right" valign="top"><a id="af5e3d9b52bdfc2f7a4f5f130482d6aea"></a>
std::vector&lt; <a class="el" href="struct_ublox_message_handler.html">UbloxMessageHandler</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#af5e3d9b52bdfc2f7a4f5f130482d6aea">handlers</a></td></tr>
<tr class="memdesc:af5e3d9b52bdfc2f7a4f5f130482d6aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of message handler objects, contains filter and callback function to handle incoming messages. <br /></td></tr>
<tr class="separator:af5e3d9b52bdfc2f7a4f5f130482d6aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aa28cea80049a79faa86c6b432c1c979b"><td class="memItemLeft" align="right" valign="top"><a id="aa28cea80049a79faa86c6b432c1c979b"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aa28cea80049a79faa86c6b432c1c979b">SYNC_1</a> = 0xb5</td></tr>
<tr class="memdesc:aa28cea80049a79faa86c6b432c1c979b"><td class="mdescLeft">&#160;</td><td class="mdescRight">value of the first sync byte at buffer[0] <br /></td></tr>
<tr class="separator:aa28cea80049a79faa86c6b432c1c979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17a0f732c3ac679812be90ede414657"><td class="memItemLeft" align="right" valign="top"><a id="ad17a0f732c3ac679812be90ede414657"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#ad17a0f732c3ac679812be90ede414657">SYNC_2</a> = 0x62</td></tr>
<tr class="memdesc:ad17a0f732c3ac679812be90ede414657"><td class="mdescLeft">&#160;</td><td class="mdescRight">value of the second sync byte at buffer[1] <br /></td></tr>
<tr class="separator:ad17a0f732c3ac679812be90ede414657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0778c1c51e238969ee18424cc86d8f"><td class="memItemLeft" align="right" valign="top"><a id="a8f0778c1c51e238969ee18424cc86d8f"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a8f0778c1c51e238969ee18424cc86d8f">CLASS_OFFSET</a> = 2</td></tr>
<tr class="memdesc:a8f0778c1c51e238969ee18424cc86d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">offset in buffer where the message class is stored <br /></td></tr>
<tr class="separator:a8f0778c1c51e238969ee18424cc86d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e2fb3cfb9989aa8277fa3fdd5ba0ad"><td class="memItemLeft" align="right" valign="top"><a id="aa4e2fb3cfb9989aa8277fa3fdd5ba0ad"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#aa4e2fb3cfb9989aa8277fa3fdd5ba0ad">ID_OFFSET</a> = 3</td></tr>
<tr class="memdesc:aa4e2fb3cfb9989aa8277fa3fdd5ba0ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">offset in buffer where the message ID is stored <br /></td></tr>
<tr class="separator:aa4e2fb3cfb9989aa8277fa3fdd5ba0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a158317920202a060c1f1e5a4c146c"><td class="memItemLeft" align="right" valign="top"><a id="af7a158317920202a060c1f1e5a4c146c"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#af7a158317920202a060c1f1e5a4c146c">DATA_OFFSET</a> = 6</td></tr>
<tr class="memdesc:af7a158317920202a060c1f1e5a4c146c"><td class="mdescLeft">&#160;</td><td class="mdescRight">offset in buffer where data begins (after sync, class, id, and length) <br /></td></tr>
<tr class="separator:af7a158317920202a060c1f1e5a4c146c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485061db54b87a302b4a98ad9ba5ad7e"><td class="memItemLeft" align="right" valign="top"><a id="a485061db54b87a302b4a98ad9ba5ad7e"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a485061db54b87a302b4a98ad9ba5ad7e">HEADER_PLUS_CRC_LEN</a> = 8</td></tr>
<tr class="memdesc:a485061db54b87a302b4a98ad9ba5ad7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">size of the header data (6 bytes) plus CRC (2 bytes). Minimum size of a valid packet with 0 bytes of payload data. <br /></td></tr>
<tr class="separator:a485061db54b87a302b4a98ad9ba5ad7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ee3f585a248fe47a308ba0587c4999"><td class="memItemLeft" align="right" valign="top"><a id="ac5ee3f585a248fe47a308ba0587c4999"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#ac5ee3f585a248fe47a308ba0587c4999">CRC_START_OFFSET</a> = 2</td></tr>
<tr class="memdesc:ac5ee3f585a248fe47a308ba0587c4999"><td class="mdescLeft">&#160;</td><td class="mdescRight">offset in buffer where the CRC calculation starts (does not include sync bytes) <br /></td></tr>
<tr class="separator:ac5ee3f585a248fe47a308ba0587c4999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c8fb1cc3cf444253f0711f7587035"><td class="memItemLeft" align="right" valign="top"><a id="a947c8fb1cc3cf444253f0711f7587035"></a>
static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ublox_command_base.html#a947c8fb1cc3cf444253f0711f7587035">CRC_HEADER_LEN</a> = 4</td></tr>
<tr class="memdesc:a947c8fb1cc3cf444253f0711f7587035"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of header bytes included in the CRC. The total CRC length is this plus payloadLen. <br /></td></tr>
<tr class="separator:a947c8fb1cc3cf444253f0711f7587035"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for reading or writing a u-blox command. </p>
<p>You normally won't use this class directly, but will do so indirectly two ways:</p>
<ul>
<li>Using UbloxCommand&lt;&gt; a templated version with a buffer to store a commmand you're building and will evenutally send to the modem</li>
<li>Using <a class="el" href="class_ublox.html" title="Class for implementing u-blox GPS support.">Ublox</a>, the class for managing the modem, which subclasses this for received messages and acknowledgements. </li>
</ul>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="adfa70f366997c784b1d41aa8a4418d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa70f366997c784b1d41aa8a4418d91">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_ublox_command_base.html#adfa70f366997c784b1d41aa8a4418d91">UbloxCommandBase::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>u-blox parsing state constants </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adfa70f366997c784b1d41aa8a4418d91ab64d8c8054fdfc6dab8b856c7aa09858"></a>LOOKING_FOR_START&#160;</td><td class="fielddoc"><p>Looking for the first sync byte (SYNC_1, 0xb5) </p>
</td></tr>
<tr><td class="fieldname"><a id="adfa70f366997c784b1d41aa8a4418d91a8f51100c7f9334d754f35a4291c892db"></a>LOOKING_FOR_LENGTH&#160;</td><td class="fielddoc"><p>Waiting for DATA_OFFSET bytes to arrive so we can check the length. </p>
</td></tr>
<tr><td class="fieldname"><a id="adfa70f366997c784b1d41aa8a4418d91abfa1f0ec96ca1a5490b0c3a846d7479c"></a>LOOKING_FOR_MESSAGE&#160;</td><td class="fielddoc"><p>Waiting for the rest of the message (HEADER_PLUS_CRC_LEN + payloadLen bytes) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9263f0d1a04cccb5cd18827f5d6bef36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9263f0d1a04cccb5cd18827f5d6bef36">&#9670;&nbsp;</a></span>UbloxCommandBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UbloxCommandBase::UbloxCommandBase </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="class_ublox_command_base.html" title="Class for reading or writing a u-blox command.">UbloxCommandBase</a> object. Normally you'd use <a class="el" href="class_ublox_command.html" title="Class to hold a command to send or a command to decode.">UbloxCommand</a> instead, which handles the buffer management for you. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer a buffer. Must remain valid for the life of this object. Must not be NULL.</td></tr>
    <tr><td class="paramname">bufferSize</td><td>Size of the buffer, a minimum of HEADER_PLUS_CRC_LEN (8) bytes. You will overwrite memory if the buffer is smaller than that. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae086799cdb19344e81cc4fbb1579c552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae086799cdb19344e81cc4fbb1579c552">&#9670;&nbsp;</a></span>addHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UbloxCommandBase::addHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ublox_message_handler.html">UbloxMessageHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a message handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>A pointer to a filled in <a class="el" href="struct_ublox_message_handler.html" title="Structure holding information about a message handler.">UbloxMessageHandler</a> structure.</td></tr>
  </table>
  </dd>
</dl>
<p>Note the handler object must remain valid until removeHandler is called on it, so you probably want to make it a global variable or allocated with new. The exception is if you have a blocking function call and add and remove the handler within the scope of the function, then you can allocate the object on the stack. </p>

</div>
</div>
<a id="a64d3c7bf15161fe9d7ddfa228e5027bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d3c7bf15161fe9d7ddfa228e5027bc">&#9670;&nbsp;</a></span>appendData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::appendData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends data into the buffer at the current payloadLen. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the data to copy from.</td></tr>
    <tr><td class="paramname">dataLen</td><td>The length of the data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it was copied or false if not</dd></dl>
<p>The data will be copied only if it will fit in the buffer entirely. The data will never be truncated. The payloadLen will be increased by dataLen bytes. </p>

</div>
</div>
<a id="aae374f6e713344bbe13d186f7b143ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae374f6e713344bbe13d186f7b143ead">&#9670;&nbsp;</a></span>appendI1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::appendI1 </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a int8_t value to the current end of the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit. </p>

</div>
</div>
<a id="a65dadab2a36ba3cfc0c1517c52395ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dadab2a36ba3cfc0c1517c52395ecd">&#9670;&nbsp;</a></span>appendI2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::appendI2 </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append an int16_t value to the current end of the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. </p>

</div>
</div>
<a id="a87c0832061f228e8ec044fc4d0db027a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87c0832061f228e8ec044fc4d0db027a">&#9670;&nbsp;</a></span>appendI4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::appendI4 </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a int32_t value to the current end of the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. </p>

</div>
</div>
<a id="aa9f5f4889713ab6be8b0ec9bab182495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f5f4889713ab6be8b0ec9bab182495">&#9670;&nbsp;</a></span>appendR4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::appendR4 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a float (4 byte floating point) value to the current end of the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. </p>

</div>
</div>
<a id="aca88125e18a5018d70cc594e4943824a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca88125e18a5018d70cc594e4943824a">&#9670;&nbsp;</a></span>appendR8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::appendR8 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a double (8 byte floating point) value to the current end of the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. </p>

</div>
</div>
<a id="a06d9d12a5f0c11844a939dba462a2781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d9d12a5f0c11844a939dba462a2781">&#9670;&nbsp;</a></span>appendU1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::appendU1 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a uint8_t value to the current end of the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit. </p>

</div>
</div>
<a id="a0eea3ddda57d3d85983bb0338b56b9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eea3ddda57d3d85983bb0338b56b9c3">&#9670;&nbsp;</a></span>appendU2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::appendU2 </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a uint16_t value to the current end of the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. </p>

</div>
</div>
<a id="aa027e266c4b9ad381bfb572f81496d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa027e266c4b9ad381bfb572f81496d0d">&#9670;&nbsp;</a></span>appendU4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::appendU4 </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a uint32_t value to the current end of the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to append</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. </p>

</div>
</div>
<a id="aaf4da9aa9fbba3ffc7d7484fbaf7ddd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4da9aa9fbba3ffc7d7484fbaf7ddd6">&#9670;&nbsp;</a></span>calculateChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UbloxCommandBase::calculateChecksum </td>
          <td>(</td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>ckA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>ckB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the checksum based on the data in the buffer. </p>
<p>The checksum is calculated not including the sync bytes or the CRC itself. This method returns the checksum values as parameters, so you can compare them.</p>
<p>The <a class="el" href="class_ublox_command_base.html#ae7d1e2235a35f385c4d52b28e2354357" title="When preparing a command to send, updates the checksum, sync, and length bytes.">updateChecksum()</a> method is typically used to calculate it for sending. </p>

</div>
</div>
<a id="aece0b19378edc0a6d4f91afab2e38aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece0b19378edc0a6d4f91afab2e38aaa">&#9670;&nbsp;</a></span>decode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::decode </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a single character. </p>
<p>This is called after reading data from the GPS by serial or I2C. </p>

</div>
</div>
<a id="a2d2adc2d96ff22c588fdacbc0ef0e0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d2adc2d96ff22c588fdacbc0ef0e0a2">&#9670;&nbsp;</a></span>fillData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::fillData </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Works like <a class="el" href="class_ublox_command_base.html#a64d3c7bf15161fe9d7ddfa228e5027bc" title="Appends data into the buffer at the current payloadLen.">appendData()</a>, but fill with a value instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The uint8_t value to set. Often 0 to initialize to zero.</td></tr>
    <tr><td class="paramname">dataLen</td><td>The number of bytes to fill with value.</td></tr>
  </table>
  </dd>
</dl>
<p>Handy for pre-creating zero-filled command buffers that are zeroed out. </p>

</div>
</div>
<a id="a047170818080f4badf0620a1f459f7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047170818080f4badf0620a1f459f7c0">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* UbloxCommandBase::getBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the buffer, typically to send data. </p>
<p>This is a pointer to the first sync byte. </p>

</div>
</div>
<a id="a77e19c1e96d033e46667e1d3840be609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e19c1e96d033e46667e1d3840be609">&#9670;&nbsp;</a></span>getData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* UbloxCommandBase::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const pointer to the data payload. </p>
<p>There are other methods to copy the data, and read out values like U2, R4, etc.. </p>

</div>
</div>
<a id="a8bb3dd16ba5a250aa8de3419a9db7819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb3dd16ba5a250aa8de3419a9db7819">&#9670;&nbsp;</a></span>getData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::getData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies data from the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset to being reading from. This is relative to the data payload, so 0 is the first byte of payload data (not the sync byte)</td></tr>
    <tr><td class="paramname">data</td><td>Buffer to copy data into</td></tr>
    <tr><td class="paramname">dataLen</td><td>The length of the data. This must be &lt;= (payloadLen - offset)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the data could be retrieved or false if it could not</dd></dl>
<p>Will only return true if all of the data can be returned. If offset + dataLen &gt; the payloadLen the false will be returned and no data will be returned. </p>

</div>
</div>
<a id="ada96285fe2158d42634140395fb53a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada96285fe2158d42634140395fb53a3e">&#9670;&nbsp;</a></span>getI1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int8_t UbloxCommandBase::getI1 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a int8_t value (signed) at offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abad8f5d8d4b200f4f81f9f3ca09b0f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad8f5d8d4b200f4f81f9f3ca09b0f2a">&#9670;&nbsp;</a></span>getI2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t UbloxCommandBase::getI2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a int16_t value (little endian, signed) at offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a168ded9ad47fa30ae603d686361c9394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168ded9ad47fa30ae603d686361c9394">&#9670;&nbsp;</a></span>getI4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t UbloxCommandBase::getI4 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a int32_t value (little endian, 4 bytes, signed) at offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4346dd7808f05bdf8acef3bed7305fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4346dd7808f05bdf8acef3bed7305fbf">&#9670;&nbsp;</a></span>getMsgClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t UbloxCommandBase::getMsgClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the message class of the current command. </p>
<p>This can be used from a message handler to find the message class of the message that is being handled. </p>

</div>
</div>
<a id="a6bd331b5f31f22d5fc973f75ad944511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd331b5f31f22d5fc973f75ad944511">&#9670;&nbsp;</a></span>getMsgId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t UbloxCommandBase::getMsgId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the message ID of the current command. </p>
<p>This can be used from a message handler to find the message id of the message that is being handled. </p>

</div>
</div>
<a id="aa30dd417787f80a9575984da3d69d127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30dd417787f80a9575984da3d69d127">&#9670;&nbsp;</a></span>getR4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float UbloxCommandBase::getR4 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a float value (4 bytes) at offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f9bc6f1a01c10d7646abc18ea4a4b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9bc6f1a01c10d7646abc18ea4a4b9d">&#9670;&nbsp;</a></span>getR8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double UbloxCommandBase::getR8 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a double value (8 bytes) at offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab07d0e1ef2a41d6b85ff9eed360a8d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07d0e1ef2a41d6b85ff9eed360a8d26">&#9670;&nbsp;</a></span>getSendLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t UbloxCommandBase::getSendLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of the data, typically to send it. </p>
<p>It's the length from the first sync byte through the last CRC byte, including the data payload. </p>

</div>
</div>
<a id="a78a0c4b229a790013191f236f3b1d9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a0c4b229a790013191f236f3b1d9d6">&#9670;&nbsp;</a></span>getU1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t UbloxCommandBase::getU1 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a uint8_t value at offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af29197d921458c875da464d368f23667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29197d921458c875da464d368f23667">&#9670;&nbsp;</a></span>getU2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t UbloxCommandBase::getU2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a uint16_t value (little endian) at offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75b475884d9b26285d94c7e34153dd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b475884d9b26285d94c7e34153dd26">&#9670;&nbsp;</a></span>getU4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UbloxCommandBase::getU4 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a uint32_t value (little endian, 4 bytes) at offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb1f896b201c033d912a7702f504d47d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1f896b201c033d912a7702f504d47d">&#9670;&nbsp;</a></span>removeHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UbloxCommandBase::removeHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ublox_message_handler.html">UbloxMessageHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a message handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The handler to remove (same value you passed to addHandler)</td></tr>
  </table>
  </dd>
</dl>
<p>Note this will not free handler as it can't know if it was allocated on the stack, as a class member, global variable, or new. If you allocated the object with new, don't forget to delete it! </p>

</div>
</div>
<a id="abb64996e19ca00e8afaf11713e47e929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb64996e19ca00e8afaf11713e47e929">&#9670;&nbsp;</a></span>setClassId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UbloxCommandBase::setClassId </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>msgId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When sending a message, sets the message class and ID. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msgClass</td><td>The class of the message </td></tr>
    <tr><td class="paramname">msgId</td><td>The ID of the message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb7a95332632c5066d69ce61c583d14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7a95332632c5066d69ce61c583d14a">&#9670;&nbsp;</a></span>setData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::setData </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set data in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset to write to. This is relative to the data payload, so 0 is the first byte of payload data (not the sync byte)</td></tr>
    <tr><td class="paramname">data</td><td>Pointer to the data to copy from.</td></tr>
    <tr><td class="paramname">dataLen</td><td>The length of the data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it was copied or false if not</dd></dl>
<p>The data will be copied only if it will fit in the buffer entirely. The data will never be truncated. The payloadLen will be increased if necessary so the data fits within the payloadLen. </p>

</div>
</div>
<a id="a7e3b8317e6f2cec6ad5de724d16b9629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e3b8317e6f2cec6ad5de724d16b9629">&#9670;&nbsp;</a></span>setI1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::setI1 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a int8_t value at offset in the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload</td></tr>
    <tr><td class="paramname">value</td><td>The value to set</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit. If the new data is larger than the current payloadLen, then the payload size is increased so it will contain the newly set data. </p>

</div>
</div>
<a id="ab18b3a8bed75047390e85a1bf32c7452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab18b3a8bed75047390e85a1bf32c7452">&#9670;&nbsp;</a></span>setI2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::setI2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an int16_t value at offset in the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload</td></tr>
    <tr><td class="paramname">value</td><td>The value to set</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. If the new data is larger than the current payloadLen, then the payload size is increased so it will contain the newly set data. </p>

</div>
</div>
<a id="aad443d6a2899b9a8c15a6e13cdbc3260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad443d6a2899b9a8c15a6e13cdbc3260">&#9670;&nbsp;</a></span>setI4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::setI4 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an int16_t value at offset in the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload</td></tr>
    <tr><td class="paramname">value</td><td>The value to set</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. If the new data is larger than the current payloadLen, then the payload size is increased so it will contain the newly set data. </p>

</div>
</div>
<a id="a84a9d4e1f5f06cb347dadae334cf177e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84a9d4e1f5f06cb347dadae334cf177e">&#9670;&nbsp;</a></span>setR4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::setR4 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an float (4 byte floating point) value at offset in the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload</td></tr>
    <tr><td class="paramname">value</td><td>The value to set</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. If the new data is larger than the current payloadLen, then the payload size is increased so it will contain the newly set data. </p>

</div>
</div>
<a id="abe715ff5f6db189e933e2ec54385fd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe715ff5f6db189e933e2ec54385fd9b">&#9670;&nbsp;</a></span>setR8()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::setR8 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an double (8 byte floating point) value at offset in the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload</td></tr>
    <tr><td class="paramname">value</td><td>The value to set</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. If the new data is larger than the current payloadLen, then the payload size is increased so it will contain the newly set data. </p>

</div>
</div>
<a id="a304c0f303a31f10fa11ce1b6ffea6772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304c0f303a31f10fa11ce1b6ffea6772">&#9670;&nbsp;</a></span>setU1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::setU1 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a uint8_t value at offset in the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload</td></tr>
    <tr><td class="paramname">value</td><td>The value to set</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit. If the new data is larger than the current payloadLen, then the payload size is increased so it will contain the newly set data. </p>

</div>
</div>
<a id="a9fc951ba43cfb76a4bb04ab72ab22428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc951ba43cfb76a4bb04ab72ab22428">&#9670;&nbsp;</a></span>setU2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::setU2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a uint16_t value at offset in the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload</td></tr>
    <tr><td class="paramname">value</td><td>The value to set</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. If the new data is larger than the current payloadLen, then the payload size is increased so it will contain the newly set data. </p>

</div>
</div>
<a id="aa857449f4958362f3bdd6694efe7e9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa857449f4958362f3bdd6694efe7e9d8">&#9670;&nbsp;</a></span>setU4()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool UbloxCommandBase::setU4 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a uint32_t value at offset in the payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset relative to the payload, so 0 is the first byte of the payload</td></tr>
    <tr><td class="paramname">value</td><td>The value to set</td></tr>
  </table>
  </dd>
</dl>
<p>The data must fit in the underlying buffer or false will be returned if it can't fit in its entirety. A partial value will never be copied. If the new data is larger than the current payloadLen, then the payload size is increased so it will contain the newly set data. </p>

</div>
</div>
<a id="ae7d1e2235a35f385c4d52b28e2354357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d1e2235a35f385c4d52b28e2354357">&#9670;&nbsp;</a></span>updateChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UbloxCommandBase::updateChecksum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When preparing a command to send, updates the checksum, sync, and length bytes. </p>
<p>The length is generated from the payloadLen member variable, which should be correct when using the set or append methods, or after manually setting the length. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_ublox_g_p_s_8h_source.html">UbloxGPS.h</a></li>
<li>src/UbloxGPS.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
